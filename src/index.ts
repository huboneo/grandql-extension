import neo4j from 'neo4j-driver';
// @ts-ignore
import {makeAugmentedSchema, inferSchema} from 'neo4j-graphql-js';
import {ApolloServer} from 'apollo-server-express';
import {HttpAdapterHost} from '@nestjs/core';
import {Inject, Module, OnModuleInit} from '@nestjs/common';
// @ts-ignore
import {SystemModule, SystemProvider} from '@relate/common';
import bodyParser from 'body-parser';

/*
 * Create an executable GraphQL schema object from GraphQL type definitions
 * including autogenerated queries and mutations.
 * Optionally a config object can be included to specify which types to include
 * in generated queries and/or mutations. Read more in the docs:
 * https://grandstack.io/docs/neo4j-graphql-js-api.html#makeaugmentedschemaoptions-graphqlschema
 */

@Module({
    imports: [SystemModule],
})
export default class GrandModule implements OnModuleInit {
    constructor(
        @Inject(HttpAdapterHost) private readonly httpAdapterHost: HttpAdapterHost,
        @Inject(SystemProvider) private readonly systemProvider: SystemProvider
    ) {
    }

    async onModuleInit() {
        if (!this.httpAdapterHost) {
            return;
        }

        const {httpAdapter} = this.httpAdapterHost;
        const app = httpAdapter.getInstance();
        const jsonBodyParser = bodyParser.json()

        const defaultAccount = await this.systemProvider.getAccount();
        const dbmss = await defaultAccount.listDbmss();
        
        // @ts-ignore
        return Promise.all(dbmss.map(async (dbms) => {
            /*
             * Create a Neo4j driver instance to connect to the database
             * using credentials specified as environment variables
             * with fallback to defaults
             */
            const boltPort = dbms.config.get('dbms.connector.bolt.advertised_address') || ':7687'
            const uri = `neo4j://127.0.0.1${boltPort}`;
            const principal = 'neo4j';
            const credentials = await this.systemProvider.getAccessToken(defaultAccount.id, dbms.id, principal);
            const driver = neo4j.driver(
                uri,
                neo4j.auth.basic(
                    principal,
                    credentials,
                ),
            );
                
            // When service launches use GraphQL schema inferred from database
            const initialSchema = await inferSchema(driver,{})

            // Workaround for handling empty database, which won't generate inferred type definitions
            // FIXME: Fix this in neo4j-graphql-js
            const initialTypedefs = initialSchema.typeDefs.includes("type") ? initialSchema.typeDefs : "type Person {name: String}"
            const schema = makeAugmentedSchema({typeDefs: initialTypedefs})
            
            /*
             * Create a new ApolloServer instance, serving the GraphQL schema
             * created using makeAugmentedSchema above and injecting the Neo4j driver
             * instance into the context object so it is available in the
             * generated resolvers to connect to the database.
             */
            const server = new ApolloServer({
                context: {driver},
                schema,
                introspection: true,
                playground: true,
            });

            // Mount GraphQL endpoint at `/grandql/{dbms.name}`
            server.applyMiddleware({app, path: `/grandql/${dbms.name}`});

            
            /* Schema management endpoint `/grandql/updateSchema/{dbms.name}
             * POST: 
             *    { schema: $typeDefs} - to set schema using $typeDefs
             *    example: 
             *     curl --location --request POST 'localhost:3000/grandql/updateSchema/foobar/' \
                     --header 'Content-Type: application/json' \
                     --data-raw '{
                      "schema": "type Person {name: String}"
                     }'
             *        
             *     or { infer: true} - to infer schema from database
             *     example:
             *     curl --location --request POST 'localhost:3000/grandql/updateSchema/foobar/' \
                     --header 'Content-Type: application/json' \
                     --data-raw '{
                      "infer": true
                     }'
             * 
             */ 
            // FIXME: does this work if there is a dbms named "updateSchema"?
            app.post(`/grandql/updateSchema/${dbms.name}/`, jsonBodyParser, async (req: any, res: any) => {
                let hotTypeDefs: string
                if (req.body && req.body.infer) {
                    const inferredSchema = await inferSchema(driver,{})
                    hotTypeDefs = inferredSchema.typeDefs
                } else {
                    hotTypeDefs = req.body.schema
                }
                console.log("Updating GraphQL schema using type definitions:")
                console.log(hotTypeDefs)

                // Generate new augmented schema using new type definitions
                // FIXME: 
                // @ts-ignore
                server.schema = makeAugmentedSchema({typeDefs: hotTypeDefs})
                res.send("Schema updated!")
            })
        }))
    }
}
